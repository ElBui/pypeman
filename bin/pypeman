#!/usr/bin/env python

import os
import sys

# Keep this import
sys.path.insert(0, os.getcwd())

import time
import tempfile
import asyncio
import traceback
import importlib
import begin


from pypeman import channels
from pypeman import endpoints


def main():
    print('Start...')

    try:
        project = importlib.import_module('project')
    except ImportError as exc:
        msg = str(exc)
        if not 'No module' in msg:
            print("IMPORT ERROR project")
            raise
        if not 'project' in msg:
            print("IMPORT ERROR project")
            raise
    except:
        import traceback
        traceback.print_exc()
        raise


    loop = asyncio.get_event_loop()

    for chan in channels.all:
        chan.import_modules()
        loop.run_until_complete(chan.start())
    for end in endpoints.all:
        loop.run_until_complete(end.start())


    print('Waiting for connection...')
    try:
        loop.run_forever()
    except KeyboardInterrupt:
        loop.close()


@asyncio.coroutine
def check_for_newerfile(future, lockfile, interval):
    exists = os.path.exists
    mtime = lambda p: os.stat(p).st_mtime
    files = dict()
    status = None

    for module in list(sys.modules.values()):
        path = getattr(module, '__file__', '')
        if path[-4:] in ('.pyo', '.pyc'): path = path[:-1]
        if path and exists(path): files[path] = mtime(path)

    while not status:
        if not exists(lockfile) or mtime(lockfile) < time.time() - interval - 5:
            status = 'error'
        for path, lmtime in list(files.items()):
            if not exists(path) or mtime(path) > lmtime:
                status = 'reload'
                print('Pending reload...')
                break
        yield from asyncio.sleep(interval)
    future.set_result(status)
    return status


def reloader_opt(to_call, reloader, interval):
    if reloader and not os.environ.get('PROCESS_CHILD'):
        import subprocess
        lockfile = None
        try:
            fd, lockfile = tempfile.mkstemp(prefix='process.', suffix='.lock')
            os.close(fd)  # We only need this file to exist. We never write to it
            while os.path.exists(lockfile):
                args = [sys.executable] + sys.argv
                environ = os.environ.copy()
                environ['PROCESS_CHILD'] = 'true'
                environ['PROCESS_LOCKFILE'] = lockfile
                p = subprocess.Popen(args, env=environ)
                while p.poll() is None:  # Busy wait...
                    os.utime(lockfile, None)  # I am alive!
                    time.sleep(interval)
                if p.poll() != 3:
                    if os.path.exists(lockfile): os.unlink(lockfile)
                    sys.exit(p.poll())
        except KeyboardInterrupt:
            pass
        finally:
            if os.path.exists(lockfile):
                os.unlink(lockfile)
        return

    try:
        if reloader:
            lockfile = os.environ.get('PROCESS_LOCKFILE')

            future = asyncio.Future()
            asyncio.async(check_for_newerfile(future, lockfile, interval))

            def done(future):
                # Stop event loop
                asyncio.get_event_loop().stop()

            future.add_done_callback(done)

            to_call()

            if future.done() and future.result() == 'reload':
                sys.exit(3)

            #print(ident(), "End task")
            #pending = asyncio.Task.all_tasks()
            #loop.run_until_complete(asyncio.gather(*pending))

        else:
            to_call()

    except KeyboardInterrupt:
        pass
    except (SystemExit, MemoryError):
        raise
    except:
        if not reloader: raise
        traceback.print_exc()
        time.sleep(interval)
        sys.exit(3)


@begin.subcommand
def start(reload: 'Make server autoreload (Dev only)'=False):
    """ Start server. """
    reloader_opt(main, reload, 2)


@begin.subcommand
def graph():
    """ Show channel graph. """

    sys.path.append(os.getcwd())
    try:
        project = importlib.import_module('project')
    except ImportError as exc:
        msg = str(exc)
        if not 'No module' in msg:
            print("IMPORT ERROR project")
            raise
        if not 'project' in msg:
            print("IMPORT ERROR project")
            raise
    except:
        import traceback

        traceback.print_exc()
        raise

    for channel in channels.all:
        if not issubclass(channel.__class__, channels.SubChannel) and not issubclass(channel.__class__, channels.ConditionSubChannel):
            print(channel.__class__.__name__)
            channel.graph()
            print('|-> out')
            print()


@begin.start
def run():
    """ Pypeman is a minimalistic but pragmatic ESB/ETL in python """
